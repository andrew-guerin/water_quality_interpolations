# this script runs the interpolation for pH
# it is the 'single thread' version of the process. Considerable speed gains are possible using multi-thread version (provided at the end, as hashed out code)
# this is for the 'best' interpolation, using zero-nugget interpolation
# this code is intended to be used with the full pH database, which contains records which are not shareable. It would need to be adjusted for the reduced dataset 

library(tidyverse)
library(sf)
library(gstat)
library(raster)
library(automap)

#prep file structure (if required)
if(!file.exists("rasters")){
  dir.create("rasters")
}

if(!file.exists("rasters/unmasked")){
  dir.create("rasters/unmasked")
}

#coordinate reference systems 
crs1 <- 4326 
crs2 <- "ESRI:102008"

#import pH data, convert to spatial data and project to North America Albers Equal Area Conic
ph.sites<- read.csv("data/interpolation_data_ph_208784.csv") %>%
  st_as_sf(coords = c("LONGITUDE", "LATITUDE"), crs = crs1, agr = "constant")  %>%
  st_transform(crs = crs2) 

#create interpolation grid encompassing Canada and USA
bbox <- c(
  "xmin" = -5000000,
  "ymin" = -1650000,
  "xmax" = 2990000,
  "ymax" = 4520000)

grid10km <- expand.grid(
  X = seq(from = bbox["xmin"], to = bbox["xmax"], by = 10000),
  Y = seq(from = bbox["ymin"], to = bbox["ymax"], by = 10000)) %>%
  mutate(Z = 0)  %>% 
  raster::rasterFromXYZ(crs = crs2) 

#check projections 
st_crs(ph.sites)
st_crs(grid10km)

#fit kriging variogram - with fixed zero nugget
#have to use custom version of autofitVariogram given problems with impossibly large distances being generated by the function
#see: https://stackoverflow.com/questions/50881168/gstat-in-r-variogram-cutoff-distance-is-not-working-at-larger-specified-distan
#and: https://stackoverflow.com/questions/68955818/autofitvariogram-in-automap-cutoff-option-doesnt-work (source of solution)

source("scripts/my_autofitVariogram.r")

varKRph <- my_autofitVariogram(MEDIAN ~ 1, 
                               as(ph.sites, "Spatial"),
                               verbose=TRUE,
                               fix.values = c(0,NA,NA),
                               boundaries=c(2, 4, 6, 9, 12, 15, 25, 35, 50, 65, 80, 100)*30000)

#inspect variogram
plot(varKRph)

#interpolation model
KRphmod <- gstat(formula=MEDIAN~1,
                 locations=as(ph.sites,"Spatial"),
                 model=varKRph$var_model,
                 nmax=100,
                 nmin=15)

#interpolation - using gstat::predict (more complex to parallelise, so is single-thread here for simplicity - but produces variance map)
KRgrid10km <- as(grid10km, "SpatialGrid")
KRph_interpolation <- predict(KRphmod, KRgrid10km, debug.level = -1)

#convert output to rasters and save 
KRph_interpolation_raster <- raster(KRph_interpolation) 
KRph_interpolation_variance_raster <- raster(KRph_interpolation, layer = "var1.var") 

writeRaster(KRph_interpolation_raster, "rasters/unmasked/ph-KR-208784-median_10km_UT_ZN.tif", overwrite=TRUE)
writeRaster(KRph_interpolation_variance_raster, "rasters/unmasked/ph-KR-208784-median_10km_UT_ZN_variance.tif", overwrite=TRUE)


#multi-thread version (considerably faster, but does not generate kriging variance map)
#takes advantage of built in multi-thread support in raster package

#library(snow)

#specify number of cores to use by setting n, or run beginCluster() without specifying - function will set n automatically
#beginCluster(n=***)
#KRph_interpolation_mt <- clusterR(grid10km, interpolate, args=list(KRphmod)) 

#final raster will be identical to version produced using single-thread approach above
#writeRaster(KRph_interpolation_raster_mt, "rasters/unmasked/ph-KR-208784-median_10km_UT_ZN.tif")



